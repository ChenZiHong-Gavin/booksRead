# SARA：在工业环境下用于安卓系统的重放增强型记录和重放

## 摘要

录制和回放工具对于移动应用的质量保证是必不可少的。

由于它的重要性，很大一批工具被开发出来录制和回放安卓的用户交互行为。

然而，通过对工业环境下各种现有工具进行实证研究，研究人员发现在工业环境下要求的性能与公开可用的录制回放工具的性能中存在一定的差距。

这项研究得出结论，在评估中没有一件现有的工具能够满足现有的工业应用。

在这篇文章中，我们展示了一个叫做SARA的录制回放工具，用来弥补差距，旨在能够被广泛使用。

具体来说，它应用了一项动态检测技术，容纳丰富的数据源，用来满足工业界多种多样的约束。

我们提出了一项录制回放技术，在不打扰用户体验的情况下，尽可能多的记录用户输入的更多信息，从而实现准确的重放。

此外，我们设计了一种自适应重放方法，允许再不同屏幕大小和操作系统版本的设备上重放事件。

通过对53个非常流行的工业Android应用程序和265个常见使用场景的评估，我们证明了SARA在记录和重放相同或者不同设备丰富的输入源的情况下的有效性。



## 1. 介绍

移动设备已迅速成为世界上随处可见和最受欢迎的计算设备。记录和回放工具，因为它能够记录用户与应用程序的互动，并且可以以后在不同设备上进行重放，从而使开发者能够在不同的设备中一次性测试，所以在移动应用的质量保证过程中发挥了重要作用。
它能够记录用户与应用程序的互动，并在以后的时间里在不同的设备上重放，使开发者能够在不同的设备上测试应用程序
例如，使用了先进的测试选择技术，回归测试的过程可以实现自动化。
为此，开发人员和测试人员的负担得到了极大的缓解，因为在今天的应用程序开发中，手动测试仍然是首选。
大量学术界和工业界都被用于建立记录和重放工具。

然而，最近有一项研究，对现存的大部分记录回放工具进行了调查，它表明，目前可用的工具的能力与工业的需求之间存在着巨大的差距。
微信，是最受欢迎的社交媒体应用之一，拥有超过10亿的月度活跃用户，它的开发者们要求一个理想的记录和回放工具应该提供四个功能并满足四个约束条件。

这四个功能包括：

1. 记录的运动事件应基于屏幕坐标（测试者在屏幕上的触摸点）
2. 记录的运动事件应基于部件（例如，按钮，文本字段）
3. 记录的事件应该对应用程序的状态不敏感。
4. 事件之间的时序应该被记录。

四个约束条件是：

1. 不需要定制操作系统
2. 不需要对应用程序进行检测。
3. 不需要root权限。
4. 不需要应用程序的源代码。

同时，还有一些其他的共同要求，比方说，工具的源代码是可获得的（也是由微信的开发者要求的
记录的数据应该具有可读性。记录的数据应该能够在不同的屏幕尺寸和操作系统版本的设备上重放。

![image-20211118001707836](C:/Users/chen/AppData/Roaming/Typora/typora-user-images/image-20211118001707836.png)

研究表明，没有公开可用的工具能满足所有期望的特征。表1显示了三个当前实践水平最高的工具：appetizer, monkeyrunner和RERAN所表现出的特征。为了满足工业界的约束，同时实现功能，现在有三个挑战：
**记录和重放丰富的输入源**。移动设备为应用程序提供了丰富的输入来源，包括运动、按键、传感器。像GPS这样传感器输入的录制和回放通常需要一个定制的操作系统，或应用程序的源代码。
然而，根据工业界的要求，定制的操作系统是不可取的，而且应用程序的源代码通常对测试人员来说是无法获得的。因此，在各种限制条件下记录和重放具有丰富来源的输入是具有挑战性的。
**高效地记录基于小部件的运动事件**。为了实现重放期间的鲁棒性，有必要同时记录运动事件的坐标和部件。有各种方法来记录互动下的部件，但它们通常需要大量的时间开销，使得它们在工业环境中的使用不切实际。例如，Culebra需要大约10秒的时在一个小部件上执行一次点击。事实上，大多数推荐的工具只基于屏幕坐标来记录运动事件，因为在实践中，有效地记录基于坐标和部件的运动事件，同时为测试者保留良好的用户体验是不容易的。
**在不同设备上重放事件**。当应用程序被启动时，安卓系统根据设备的屏幕分辨率和尺寸，在应用程序中声明适当的布局配置。开发者被建议但没有严格要求为不同的屏幕分辨率和尺寸创建备用的UI布局和UI资源。因此，不同的屏幕尺寸和操作系统版本的设备上重放事件是非常可取的。不幸的是，如何实现这一目标仍然是一个没有定论的问题。
这次，我们设计并实现了一个名为SARA（Self-play Augmented Record and Replay for Android）的记录和重放工具，以解决上述所有的挑战，并以广泛被采用为目标。
为了实现这一目标，SARA整合了三个主要的技术：

1. 动态插桩工具被应用于种类繁多的移动设备的输入，包括来自传感器的输入。它甚至可以在前述的各种限制下也能工作，如没有定制的操作系统和源代码。
2. 自重放机制被提出来有效解决基于小部件的运动事件。具体来说，SARA首先记录用户互动期间仅基于屏幕坐标的运动事件。然后，它自动在同一设备重放所记录的事件，以识别互动中的小部件。自重放之前的记录是一个低成本的操作。因此，SARA可以基于屏幕坐标和小部件来记录运动事件，同时提供良好的用户体验。
3. 设计了一种自适应的重放方法来重放不同设备上的事件。SARA能够通过启发式搜索小部件和转换坐标来重放事件，以适应不同的屏幕尺寸和操作系统版本。

我们在三种不同的安卓设备上对SARA进行了评估，其中包括53个高度流行的工业安卓应用和265个常见的使用场景。如表1所示，SARA满足了工业界所期望的大部分特性。评估结果显示：

1. SARA能够在同一台设备上记录和重放265个常见使用场景中的228个，这远远超过了appetizer的161个和RERAN的29个。我们没有将SARA与monkeyrunner进行比较，因为它对事件的时序不敏感。事件的时序对结果非常重要。
2. SARA成功地在两个具有相同显示比例但不同屏幕尺寸的设备上重放了42个常见使用场景中的41个，比appetizer的31个要多。在两台显示比例和屏幕尺寸都不同的设备上，SARA重放了42个场景中的34个。注意，appetizer未能在不同显示长宽比的设备上重放任何事件。我们没有将SARA与RERAN进行比较，因为它不支持在不同设备上重放事件。
3. 尽管SARA应用了精密化技术，并且记录了基于小部件的运动事件，但与与原始运行时间相比，记录和重放的开销的开销分别只有4.29%和7.07%。空间开销仅为每秒1.78KB。

##  2. 相关工作

学术界和工业界在开发桌面应用程序的记录和回放工具方面已经取得了很多进展。依据它们在哪一层记录输入可以把它们分为三类：

1. Linux内核层。

   RERAN是研究人员最早提出的一个记录和重放工具。它工作在内核层。具体来说，它通过ADB的命令读取/dev/input/event*文件中的日志来捕获低级事件，并利用命令sendevent来重放事件。这些低级别的事件与硬件紧密相连，使得它很难被重组为高级手势并在其他设备上重放。 接下来的工具像Mosiac和appetizer，通过同样的途径来捕捉事件。这些工具在记录和回放一些传感器的输入的时候有一些限制，因为像GPS这样的输入没有被写入日志。

2. 安卓框架层。

   VALERA修改了安卓框架，以捕获传感器和网络输入、事件时间表和应用间通信，使其实现精确记录和回放。然而，VALERA需要一个定制的操作系统，这违反了工业界的限制。

3. 应用层

   在应用层有一堆记录输入数据的工具。具体来说，Mobiplay采用了客户端-服务器架构，包括一个运行在移动设备上的客户端应用和一个运行在服务器上的目标应用上，来拦截对应用程序的输入。然而，在没有应用的源代码的情况下，它不能重放传感器输入，如GPS。
   Espresso通过一个调试器来记录基于小部件和关键事件的运动事件。但它不能记录传感器输入
   和复杂的手势，如缩放，捏合，而且它还需要应用程序的源代码。Robotium是Selenium网页浏览器自动化工具衍生出来的。它只能够拦截那些由应用程序的主进程控制的小部件。

在评估过程中，我们发现大多数流行的工业应用实际上启动了不止一个进程。

Culebra在桌面上提供了一个图形用户界面，供用户与记录中的应用程序进行互动。在将用户的操作发送到应用程序之前，Culebra试图在视图层识别将要被交互的小部件。这在方法上与MobiPlay非常相似。但它引入了大量的时间开销，并且不能记录传感器的输入。
Ranorex是一个跨平台的商业测试自动化工具。它支持通过动态插桩记录基于坐标和部件的事件。但它不能记录传感器的输入，也不能对大尺寸的应用程序进行测试。SARA也属于这个类别。
它被设计用来记录和重放各种类型的输入，并满足工业界要求的限制条件。

## SARA的设计

在这一节中，我们将详细阐述SARA背后的设计。以及SARA如何解决在工业界要求的各种限制下提供功能的挑战。

### 3.1 通过动态插桩录制和回放丰富的输入源

在现有的工具中，在移动设备上记录和回放丰富的输入源，通常需要定制的操作系统或应用程序的源代码。

然而，行业开发者并不赞成需要定制操作系统的工具。
安装一个定制的操作系统在实践中很耗时，而且容易出错，因为定制的操作系统可能与设备不兼容。
另一个主要问题是，在自定义操作系统中记录的事件可能无法转移到官方的Android操作系统中。
开发人员也不喜欢需要应用程序的源代码的工具。因为他们有时会把测试工作外包给其他公司。

然而，在没有定制操作系统的情况下，记录和重放丰富的输入源
然而，在没有定制的操作系统和源代码的情况下，记录和重放丰富的输入源是不容易的，特别是对于那些来自传感器的输入，如GPS。

> Instrumentation是一种直接修改程序二进制文件的方法。其可以用于程序的调试，优化，分析[5]，安全[4]等等。对这个词一般的翻译是“插桩”，但这更多适用于软件测试领域。Instrumentation一般可以分为两类，动态和静态。动态修改是在目标进程运行时插入代码(dynamic binary instrumentation)。

为了应对这一挑战，SARA应用了动态插桩方法。首先，丰富的输入源被传递到应用层，允许开发者对其进行处理。与Linux内核层和Android框架层相比，该层中的输入数据在设计上是更高级的。
因此，在应用层记录输入数据的最突出的优点是，所记录的数据是人类可读的，并且容易被重新组变成高级手势，如缩放，使测试人员相当容易地分析、修改和重新组合这些数据以达到进一步测试的目的。
第二，动态插桩，在应用程序的运行时工作，不需要定制的操作系统或源代码。它也几乎不受打包技术的影响，这些技术在Android平台上越来越流行，用于隐藏代码。
这是因为隐藏的dex代码将被解压，以便在运行时被执行。
SARA的动态工具技术在重放传感器输入方面也发挥了重要作用，例如GPS。
请注意，微信的开发者也不赞成使用插桩，因为他们担心插桩工具和应用程序之间的兼容性问题。
仪器化工具和应用程序之间的兼容性。但正如我们将在第5节中所展示的，SARA与微信和其他高度流行的工业应用程序兼容，这在一定程度上解除了他们的顾虑。

### 3.2 自重放高效记录基于小部件的运动事件

行业开发者想要一个记录和回放工具，用来记录基于坐标和部件的事件。直观地说，基于小部件记录的事件比那些仅仅基于坐标来记录的事件更具有鲁棒性。有各种各样的方式来记录互动下的小部件，但它们通常引入了大量的开销，因为关于部件的信息要比坐标复杂得多。
例如，Espresso能够在记录过程中通过将调试器附加到应用程序上来拦截小部件。但这不可避免地导致了应用程序的缓慢反应，并因此导致用户体验不佳。
为了有效地记录基于坐标和小工具的事件，同时提供可靠的可用性，SARA引入了一种新颖的自重放机制，将一个典型的记录阶段分成两个子阶段。

第一阶段的目标是记录基于坐标的事件。这不会引入太多的开销，从而提供良好的用户体验。第二阶段的目标是在前一阶段记录的事件的基础上，增加相关的小工具的信息。具体来说，SARA在记录设备上自动重放事件，并在交互中有效地识别互动中的小部件。
在相互作用下。在第二阶段引入的额外开销对测试人员来说是透明的。为此，SARA能够记录
基于坐标和部件的事件，同时保留了良好的用户体验。
值得注意的是，自我重放机制可以很容易地被纳入现有的记录和重放工具中。例如，它可以在Mobiplay的记录阶段结束时加入，从而使由MobiPlay记录的事件既是坐标导向的也是小部件导向的。

### 3.3 自适应重放

尽管所有的事件都被记录下来了，而且运动事件甚至被赋予了小部件信息，但在不同的设备上重放运动事件仍然是一项具有挑战性的任务。
其主要原因如下：

首先，一个应用程序的同一上下文中的视图层次在不同的设备上通常是不同的，特别是当层次中存在着可滚动小部件。一个可滚动小部件中的项目数量与屏幕尺寸密切相关。

例如，在设备中，一个可滚动的小组件可以有7个可见的项目，但在一个更小的屏幕上，只有5个项目。
第二，对于一些高级运动手势诸如swipe，小组件的信息仍然不足以准确地回放，因为swipe的轨迹也很重要，特别是对于那些绘图的场景。最后，在不同的设备上偶尔会观察到UI布局的突破性化。
为了解决这些问题，我们提出了一种自适应重放方法。特别的，SARA通过启发式搜索来重放事件
来重放事件，例如，自动滑动可滚动的小部件，并且根据重放设备的屏幕参数转换坐标，以适应布局。

## 4. 补充

在本节中，我们首先说明了SARA的整体三阶段工作流程。然后，我们展示了这三个阶段的实施
阶段的详细实现。

### 4.1 SARA总览

![image-20211118115229275](C:/Users/chen/AppData/Roaming/Typora/typora-user-images/image-20211118115229275.png)

SARA在一个三阶段的过程中运作，以便记录和重放。图1描述了SARA的工作流程。在记录阶段，
SARA记录所有的输入数据，包括运动、按键和传感器输入，并将它们解析为事件。

然后在自我重放阶段，用相关的部件数据来增加记录的事件。
也就是SARA自动重放记录设备上的事件，并识别互动中的小部件。

最后在重放阶段，SARA启发式地搜索寻找小部件，并根据重放设备的屏幕参数进行坐标转换。

### 4.2 记录阶段

这个阶段的目标是精确记录输入和两个连续输入之间的时间。
SARA通过其记录模块完成了这一目标。它的记录模块由记录器和解析器组成。

**记录器**。

记录器的重点是捕捉丰富的输入来源。
正如第3.1节所讨论的，SARA通过应用动态插桩技术在应用层记录输入数据。

通常情况下，Android应用程序的输入可以分为三类。即运动、按键输入和传感器。在下文中，我们将描述Recorder是如何在应用层中捕捉这三类输入的。

#### 4.2.1 运动输入。

安卓框架提供的服务向活动的应用程序提供运动输入。这些运动输入从应用程序的视图层次结构的顶部开始调度，然后向下，直到直到到达目标部件。因此，为了拦截所有的运动输入，Recorder动态地使用了活动、对话框和弹出窗口中的视图的dispatchTouchEvent方法，记录输入数据（例如，坐标、动作代码）和这个阶段开始后的时间。请注意，记录器在这个阶段记录基于坐标记录运动输入。SARA原则上能够识别所有种类的运动手势，因为开发者也在dispatchTouchEvent方法中识别它们。

#### 4.2.2按键输入。

按键输入可以进一步划分为物理键输入（例如，返回、音量增大）和软键盘输入。
类似于动作输入，Recorder通过动态地对活动和对话的dispatchKeyEvent方法进行拦截，记录输入数据（例如，按键代码）和从该阶段开始的时间。
不同的是，软键盘输入通常被传递到active输入方法。然后，输入方法通过进程间通信将输入传递给活动的应用程序。

具体来说，InputConnection接口提供了一个通信通道，从输入法到接收输入的应用程序的通信渠道。因此，Recorder使用beginBatchEdit中和InputConnection来记录软键盘的输入数据（例如，输入内容、被输入的文本视图）。
请注意，对于WebView，Recorder通过在网页中注册一个输入监听器来捕捉按键输入数据。
监听器。

####  4.2.3 传感器输入。

智能手机提供了比台式机/服务器更丰富的传感器组合
它们可以被划分为低级别的和高级传感器。低级传感器包括加速度计、重力计、陀螺仪等。开发者能够通过覆盖onSensorChanged方法来检索。
因此，Recorder拦截了低级别的传感器数据。至于高级传感器，如GPS，Android提供了丰富的API来处理每一种输入。
例如，当GPS/位置改变时，Android框架会向LocationListener传递一个消息来通知应用程序。开发者可以通过覆盖LocationListener来处理
因此，Recorder也拦截onLocationChanдed来记录位置数据。需要注意的是，当阶段开始时。因此，Recorder也会对ClassLoader的loadClass方法进行检测，以便在该方法被加载后能够执行。
一旦该方法被加载，它就可以执行插桩。

**解析器**。

应用层的输入数据是高层次的，使其容易被解析为可读的事件。例如，两个
连续的运动输入，共享相同的坐标和用户按下时的时间，或简称为向下时间，可以被归类到一起。根据自下压时间以来所经过的时间，分组后的输入可以被解析为一个轻拍或一个长拍。
特别是，Parser遵循官方的Android开发指南准则来解析运动输入、按键输入和传感器输入。
我们将解析器的解析结果定义为事件，包括运动事件、输入事件和传感器事件。此外，事件之间的时间可以由解析器精确计算，因为记录器记录了自记录阶段开始时输入的时间捕获。

### 4.3 自重放阶段

这个阶段的目标是通过自重放，用相关的小部件数据来增强运动事件。
SARA通过一个由候选识别器和重放器组成的自我重放模块来实现这一目标。
算法1概述了这个阶段的过程。

![image-20211118121100864](C:/Users/chen/AppData/Roaming/Typora/typora-user-images/image-20211118121100864.png)

它将记录阶段记录的事件作为输入，并输出增强后的事件。

**候选识别器。**

候选识别器负责识别互动中的小部件，并为每个小部件生成一个唯一标识符，以便它们能够在接下来的重放阶段被唯一地识别。

在重放一个动作事件之前，候选识别器会在一个应用程序的视图层次中识别候选的小部件。
如果该事件的坐标位于一个小部件的区域内（由小部件的位置和大小决定），那么，那么这个部件就被视为一个候选部件。因为小部件之间的重叠与视图层次结构缺乏，候选者的数量通常大于1。
因此，为了确定性地识别被交互的部件，候选识别器对每个候选部件执行插桩，以记录它是否收到
一个输入。最后一个收到运动输入的部件被视为被视为目标部件。
一旦目标部件被识别，候选识别器就会为其生成一个唯一的标识符。
特别是，候选识别器在视图层次中搜索一个最短路径来唯一地识别目标部件，以一种自下而上的方式。这个xpath最终被作为该部件的标识符。

**重放器**。重放器负责重放记录设备上的事件。
就运动事件和按键事件而言，Replayer利用UIAutomator来重放这些事件，因为它提供了一套API来执行应用程序上的交互，如滑动，按键和设置文本。至于传感器事件，安卓并没有提供任何工具来向应用程序注入传感器事件。但我们发现,即使传感器的数据没有被改变,传感器事件监听器的onSensorChanged方法将被调用。
此外，读取的频率是在应用程序中配置的。因此，为了重放低级别的传感器输入，Replayer
做出了一个假设，即频率在整个过程中保持不变。

基于这一假设，Replayer动态地记录onSensorChanged方法，并将读取的传感器数据实时替换为
数据替换为实时记录的数据。

因此，动态插桩技术使SARA能够在没有定制操作系统和源代码的情况下重放传感器输入。

### 4.4 重放阶段

这一阶段的目标是在具有不同屏幕尺寸和操作系统版本的不同设备上重放事件。
SARA通过一个重放模块来实现这一目标，该模块由小部件识别器、坐标转换器和重放器组成。
该模块中的Replayer与自重放模块中的Replayer相同。

不同之处在于在这个重放阶段，运动事件的重放是基于在小部件和转换坐标的基础上进行重放。

算法2概述了在这个阶段对运动事件的重放过程。

![image-20211118122107686](C:/Users/chen/AppData/Roaming/Typora/typora-user-images/image-20211118122107686.png)

小部件识别器首先识别出目标小部件（第1行）。如果该小部件被被识别，坐标变换器就会基于屏幕尺寸和重放设备的像素密度，转换相对于小部件的坐标。
否则，坐标变换器只是转移相对于屏幕的坐标（第2-5行）。最后。Replayer基于转换后的坐标来执行事件(第6行)。

**小部件识别器。**

小部件识别器负责识别小部件。具体来说，小部件识别器首先识别视图层次中的目标部件，其唯一的标识符在自重放阶段生成。当部件识别器未能识别出目标部件时，它就会尝试通过自动滑动视图层次结构中的可滚动部件来搜索该部件。

**坐标变换器。**

坐标转化器的基本思想是，它尽力保留轨迹和在重放设备上的运动距离（第7-13行）。具体来说，
dpi（每英寸点数）指的是屏幕上像素的物理密度，过程px2dp将像素（px）转换为与密度无关的
像素（dp），这是Android中常用的距离单位，因为它保留了不同像素的设备上的可见尺寸或距离。程序dp2px则进行反向转换。



### 4.5 工具实现

SARA被实现为一个桌面应用程序，可以在Windows和Linux操作系统上运行。具体来说，SARA的记录模块中的记录器主要由Frida实现，Frida是一个跨平台的动态工具箱，它能够在没有root权限的情况下对应用程序进行检测。自我播放模块和重放模块中的重放器主要由Android uiautomator2 [6]和Frida的python包装器实现。候选识别器和小工具识别器都严重依赖视图层次，这是由uiutomator2和ADB命令adb shell dumpsys activity top提取的。

## 5. 评估

本节中，我们对SARA在记录和重放事件方面的有效性以及它的开销进行了评估。
按照以前的工作，我们评估了SARA在同一设备上记录和重放事件的情况。此外，我们还评估了SARA在不同设备上重放事件的情况，因为它允许开发者一次在不同的设备上测试应用程序，特别是在回归测试的设置中。为此，我们研究了以下三个研究问题：
RQ1. SARA在在同一设备上记录和重放事件的效果如何？
RQ2. SARA在不同屏幕尺寸和操作系统版本的不同设备上重放事件的效果如何？
RQ3. SARA的时间和空间开销是多少？

### 5.1 评估准备

![image-20211118132702062](C:/Users/chen/AppData/Roaming/Typora/typora-user-images/image-20211118132702062.png)

我们在表2所列的3部真实手机上进行评估。
表3列出了在Google Play（安卓系统的官方应用商店）中每个类别中下载量最高的53个顶级推荐应用。采样的应用程序被要求至少与我们的两部手机兼容。
如表所示，每个应用程序至少有100万次安装，这些应用程序跨越24个不同的类别，具有代表性。对于每个被抽样的应用程序，我们进一步从其描述中找出5种常见的使用场景。
例如，我们认为Twitter的5个常见场景是："创建一个帖子"、"搜索"、"赞和评论"、"编辑个人资料 "和 "发送消息"。

![image-20211118133007566](C:/Users/chen/AppData/Roaming/Typora/typora-user-images/image-20211118133007566.png)

这265个场景涵盖了Android的每一个输入源。

详细的场景的详细描述和截图，以及SARA的源代码可以在SARA的官网上找到。

对于RQ1，SARA被用来记录和重放在同一台设备上记录和重放每个常见的使用场景。

为了建立标准，我们还评估了appetizer和RERAN，它们是研究报告中提到的安卓系统记录和重放工具的最佳工具。
我们没有评估其他最近提出并公开可用的工具，如Espresso和Culebra，因为它们要么需要应用程序的源代码，要么引入大量的时间开销。
这使我们无法对大规模的工业应用进行有效的评估。
appetizer和RERAN都是通过读取下面的日志来记录输入的/dev/input/event*文件来记录输入。appetizer的与众不同之处在于，它不需要root权限，它支持在不同的设备上重放事件。

当且仅当外部可见的状态是相同的时候，我们认为重放是正确的。

其中可见的状态是指用户看到的应用状态的子集
在重放阶段，我们手动检查外部可见状态以评估重放的正确性。
评估是在Galaxy A8设备上进行的。

对于RQ2，SARA被用来记录在一个设备上的场景，并在剩下两个设备中重放。

我们把SARA和appetizer做比较因为它具有在相同显示纵横比的设备上记录和重放事件的能力。

为了系统研究，我们随机选择42个场景，在REDMI 1s和Samsung Galaxy A8上记录，然后在剩下的设备上重放。

外部可见状态通常在不同屏幕尺寸的设备上不一样。

因此，在本研究中，当且仅当所有记录的事件都按顺序在相应的小部件上触发的时候，我们认为回放是正确的。

对于RQ3，我们通过在36个随机抽样的场景上运行SARA来测量SARA的时间和空间开销，这些场景可以通过SARA进行重放。具体来说，为了测量时间开销，我们首先记录场景的原始运行时。然后，我们将其分别与SARA的录制阶段和回放阶段场景的运行时进行比较。至于空间开销，我们测量了在记录阶段生成的事件日志的大小和日志速率。评估是在三星Galaxy A8设备上进行的。

### 5.2 在同一设备上录制和重放事件的效率

表3显示了在三星Galaxy A8上SARA（"SA."）、appetizer（"ap."）和RERAN（"RE."）的评估结果。

最后三列的表格单元中的数字表示一个工具能够录制和重放的场景数量。

灰色背景的表格单元表示与其他工具相比价值最高。

SARA, appetizer, 和RERAN能够记录和重放同一设备上265个常用场景中的86.0%、60.7%和10.9%。
很明显，SARA实现了最好的性能。RERAN性能比其他工具低得多，因为它在重放过程中通常会停止，并产生错误信息，如 "无法打开/dev/input/event0，有太多打开的文件"。这是一个众所周知的的问题，但是在它的存储库1中没有任何补丁能解决这个问题。
至于appetizer，它不能记录物理键输入，例如，点击后退按钮，而且它通常会在重放过程中遗漏几个事件
微信的开发者们不赞成插桩，因为他们担心插桩工具和应用程序之间的兼容性问题。
但正如我们在表格中所显示的，SARA与微信和其他所有的抽样软件都是兼容的，Facebook除外。
这在一定程度上解除了他们的担忧。
为了了解SARA的故障来源，我们分析了所有的失败案例，并总结了失败的主要原因，如表4所示。

![image-20211118145609958](C:/Users/chen/AppData/Roaming/Typora/typora-user-images/image-20211118145609958.png)

**在记录阶段的失败**

在20种情况下，SARA未能正确记录输入。

具体来说，SARA未能记录Facebook，占了5个失败案例。

有3个案例，SARA未能记录WebView中的特殊软键盘输入，例如，点击键盘上的
键盘上的搜索键，因为这样的输入没有被传递到网页注册的监听器上。

在另外7种情况下，SARA未能记录正确的软键盘输入。有两方面的原因。

首先，插桩工具Frida无法处理实现android.text.Editable接口的类，这个类提供丰富的方法来处理输入字符串。
我们已经在Frida的issue中开了一个issue，但是还没有收到回复。

我们尝试用一些启发式的策略来推断输入，以绕过这个问题，但在某些情况下，我们仍然错过了来自软键盘的输入，导致了5次失败。

其次，像OneNote这样的应用通过集成一个富文本编辑器来支持富文本编辑。
事实上，有很多方法可以实现富文本编辑。SARA目前只支持那些基于android.widдet.T extView的方式。因此导致了2个失败。

剩下的5个案例是由于我们在记录弹出式窗口内的运动输入。

**在自我播放阶段的失败**。

有11种情况是SARA在自我重放阶段未能重放事件。

在7种情况下，SARA未能捕捉到精确的时间来重放一个运动事件。因为在自我重放阶段，SARA在执行一个运动事件之前对候选小部件进行了检测。这不可避免地会引入时间开销。
解决这个问题的一个可能的方法是，在自我重放期间，扣除由插桩引入的平均时间开销，在
在事件之间的自我重放期间的仪器化所引入的平均时间开销。我们把它作为我们未来的工作。目前SARA的实现并不支持在旋转的屏幕上重放运动事件，这将导致另外2个故障。其余的两个失败案例是由uiautomator2在执行滑动手势时的问题引起的。

**重放阶段的失败**。

在重放阶段的6个失败案例主要是由应用程序的非确定状态引起的。
例如，在SBB Mobile中，它实时显示可用的公共汽车票，SARA无法识别目标部件，因为它的状态不断变化。
如何处理被测试的应用程序的非确定性状态仍然是一个不确定的问题。

### 5.3 在不同屏幕尺寸与操作系统上的效率

表5显示了使用SARA和appetizer都可以重放的42个抽样场景的情况。
在RedMi1s上记录场景时，SARA分别能在Galaxy A8和Galaxy A9上分别重放其中的41和34个。
然而，appetizer不支持在Galaxy A9上重放场景，因为A9与RedMi 1s的显示比例不同。

当在Galaxy A8上记录场景时，SARA能在RedMi 1s和Galaxy A9上分别重放38和32个场景，而appetizer在RedMi 1s上能重放30个场景。SARA在以下方面比appetizer更有效
在两个评估设置中，SARA在不同设备上重放场景方面比appetizer更有效。
在评估过程中，我们发现在RedMi 1s和Galaxy A8上重放场景的效果比Galaxy A9要简单得多。
即使RedMi 1s和Galaxy A8在dpi和屏幕尺寸上有所不同，在它们上面的应用程序的布局是大致相同的。因此，按比例记录的坐标，在这两种设备上效果很好
事实上，appetizer在很大程度上依赖这种缩放技术来支持在多个设备上重放事件。
与appetizer相反，SARA首先尝试搜索小部件，然后在执行运动事件之前，将坐标相对于目标部件进行转换。
在重放阶段，它在处理应用程序的状态差异方面更加稳健。图2通过一个说明性的例子展示了SARA的稳健性。
当在Galaxy A9上重放事件时，我们发现应用程序的布局通常与RedMi 1s和Galaxy A8上的布局不同。
这表明在重放过程中，单纯的缩放记录坐标是容易出错。识别互动中的小部件并基于它们进行坐标转换可以在一定程度上解决这个问题。因此，SARA能够在Galaxy A9上重放大部分的场景。
我们分析了在Galaxy A8上记录的，但是在Galaxy A9没能重放的10个场景。

失败的主要原因是，SARA未能在重放阶段识别正确的部件。
其中7个是由于uiautomator2[6]提取的视图层次不准确。
由于SARA在自我重放阶段主要依靠视图层次来寻找候选部件，如果没有一个候选部件是正确的，它就很难识别出正确的部件。
导致失败的其他因素包括包括布局上的突破性变化（如图3所示）。应用程序的非确定性状态（目标部件并不总是在应用中显示），以及在设备上执行swipe操作的uiautomator的一个问题。

### 5.4 开销

表6显示了可以用SARA重放的36个抽样场景，以及SARA在这些场景上的时间和空间开销。
SARA在这些场景中的时间和空间开销。原始时间 "表示一个场景没有应用记录和重放工具的原始运行时间，"记录阶段"和 "重放阶段 "中的 "时间 "显示的是在SARA的记录阶段和重放阶段的运行时间。
如表所示，SARA的平均记录和重放开销为分别为4.29%和7.07%。尽管SARA采用了插桩技术，
它在记录阶段的开销相对较低，这在工业环境中是非常重要的，因为测试人员会参与到这个阶段。至于重放阶段，我们发现，开销主要是在搜索部件的过程中引入的。
请注意，一些应用程序，例如ESPN，其开销约为10.21%。
经过调查，我们发现搜索目标部件的速度比大多数情况下要慢得多，因为它们在视图中的深度较深
层次结构。搜索小部件的时间开销与小部件布局的复杂性密切相关。
平均而言，SARA在记录阶段和重放阶段都实现了足够低的时间开销。

最后两列给出了SARA的空间开销，包括记录的日志的大小和速率（SARA不在电话上存储日志）。
如表所示，日志的平均大小为77KB，平均日志速率为每秒1.78KB。

极低的空间的空间开销符合我们的期望，因为SARA在应用层记录输入数据，日志的大小取决于用户操作和场景的持续时间。

## 讨论

**对有效性的威胁**

如同大多数经验性评估一样，我们提出的结果也存在着外部和内部的威胁。
在外部有效性方面。我们的结果可能无法推广到其他工业应用和其他安卓设备。

特别是，我们在RQ1，RQ2, RQ3中分别只考虑了3部真实的手机、53个行业应用和265、42和36个常见的使用场景。
这个限制是在不同设备上确定场景、设置环境和记录场景所涉及的复杂性的一个假象。
为了减轻这一威胁，我们在Google Play中抽取每个类别中下载量最高的顶级推荐应用程序，并根据Google Play的描述和我们的研究结果来确定场景。
我们选择的三款真实手机涵盖了写这篇文章的时候最广泛使用的Android操作系统版本和屏幕尺寸。
我们相信，考虑到广泛的工业应用和我们选择的代表性手机的高度流行性，SARA应该
也适用于其他工业应用和安卓设备。
在建设性的有效性方面，SARA的实施可能存在错误。为了减少这种威胁，我们广泛地检查了
评估结果。
**局限性**。

SARA仍有一些局限性。首先，混合型应用程序（混合使用本地和网络技术的应用程序
技术）在记录和重放基于小部件的事件方面带来了指导性的挑战，因为一些小部件是由
WebView渲染为HTMLElements，在视图层次中无法找到。
其次，游戏应用通常是用游戏引擎（如University）开发的。
引擎（例如Unity[37]）开发。游戏应用中的大部分小部件都是由游戏引擎渲染的，而且在视图层次中也找不到。
层次结构中，使得SARA无法与这些小工具一起工作。
微信已经是一个高度流行的工业级的安卓应用，拥有超过10亿的月度活跃用户。在这一过程中
对具有所需功能的可靠的记录和重放工具的要求对研究界和工业界来说都很有价值，这促使我们设计和实现SARA。

尽管SARA的动机来自于微信，但SARA的采用并不限于微信。
我们期待与工业伙伴合作，改进SARA，并将SARA整合到他们的测试和维护过程中。









